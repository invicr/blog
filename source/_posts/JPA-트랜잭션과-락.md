---
title: '[JPA] 트랜잭션과 락'
categories:
  - Programming
  - JPA
tags:
  - Transaction
  - Lock
  - Version
  - OptimisticLock
date: 2020-04-14 21:03:42
thumbnail:
---
### 트랜잭션

트랜잭션은 ACID를 보장해야 한다.

* 원자성(Atomicity) : 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 실패해야 한다.
* 일관성(Consistency) : 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다.
예를 들어 데이터베이스에서 정한 무결성 제약 조건을 항상 만족해야 한다.
* 격리성(Isolation) : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다.
예를 들어 동시에 같은 데이터를 수정하지 못하도록 해야 한다. 격리성은 동시성과 관련된 성능 이슈로 인해 격리 수준을 선택할 수 있다.
* 지속성(Durability) : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다.

### 트랜잭션 격리 수준

트랜잭션의 격리 수준에 대해 알아 보자. (격리 수준이 낮음 -> 높음 순서)
* READ UNCOMMITED (커밋되지 않은 읽기)
* READ COMMITED (커밋된 읽기)
* REPEATABLE READ (반복 가능한 읽기)
* SERIALIZABLE (직렬화 가능)

|격리 수준|DIRTY READ|NON-REPEATABLE READ|PHANTOM READ|
|---|:-:|:-:|:-:|
|READ UNCOMMITED|O|O|O|
|READ COMMITED||O|O|
|REPEATABLE READ|||O|
|SERIALIZABLE||||			

* DIRTY READ : 트랜잭션1이 데이터를 수정하고 있는데 커밋하지 않아도 트랜잭션2가 수정 중인 데이터를 조회할 수 있는 경우 이것을 DIRTY READ라 한다.
* NON-REPEATABLE READ (반복 불가능한 읽기) : 트랜잭션1이 회원 A를 조회 중인데 갑자기 트랜잭션2가 회원 A를 수정하고 커밋하면 트랜잭션 1이 다시 회원 A를 조회했을 때 수정된 데이터가 조회된다.
이 처럼 반복해서 같은 데이터를 읽을 수 없는 상태를 NON-REPEATABLE READ라 한다.
* PHANTOM READ : 트랜잭션1이 10살 이하의 회원을 조회했는데 트랜잭션2가 5살 회원을 추가하고 커밋하면 트랜잭션1이 다시 10살 이하의 회원을 조회했을 때 회원 하나가 추가된 상태로 조회된다.
이 처럼 반복 조회 시 결과 집합이 달라지는 것을 PHANTOM READ라 한다.

1) READ UNCOMMITED : 커밋하지 않은 데이터를 읽을 수 있다. 데이터 정합성에 심각한 문제가 발생할 수 있는 격리 수준.
2) READ COMMITED : 커밋한 데이터만 읽을 수 있다. 따라서 DIRTY READ가 발생하지 않는다. 하지만 NON-REPEATABLE READ는 발생할 수 있다.
3) REPEATABLE READ : 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. 하지만 PHANTOM READ는 발생할 수 있다.
4) SERIALIZABLE : 가장 엄격한 트랜잭션 격리 수준이다. 하지만 동시성 처리 성능이 급격히 떨어질 수 있다.

### 낙관적 락과 비관적 락

* 낙관적 락 : 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법, JPA가 제공하는 버전 관리 기능을 사용한다. 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다는 특징이 있다.
* 비관적 락 : 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법이다. 데이터베이스가 제공하는 락 기능을 사용한다.

JPA를 사용할 때 추천하는 전략은 READ COMMITTED + @Version
-> 두 번의 갱신 내역 분실 문제(Second Lost Updates Problem) 예방

* 두 번의 갱신 내역 분실 문제
사용자 A와 B가 동시에 제목이 같은 공지사항을 수정한다고 가정하자. 둘이 동시에 수정 화면을 열어서 내용을 수정하는 중에 사용자 A가 먼저 수정완료 버튼을 눌렀다.
잠시 후에 사용자 B가 수정완료 버튼을 눌렀다. 결과적으로 먼저 완료한 사용자 A의 수정사항은 사라지고 나중에 완료한 B의 수정사항만 남게된다.
두 번의 갱신 분실 문제는 데이터베이스 트랜잭션의 범위를 넘어선다. 따라서 트랜잭션만으로는 문제를 해결할 수 없고, 아래 3가지 선택 방법이 있다.
1. 마지막 커밋만 인정하기
2. 최초 커밋만 인정하기
3. 충돌하는 갱신 내용 병합하기

기본은 마지막 커밋만 인정하기가 사용된다. 하지만 상황에 따라 최초 커밋만 인정하기가 더 합리적일 수 있다. JPA가 제공하는 버전 관리 기능을 사용하면 손쉽게 최초 커밋만 인정하기를 구현할 수 있다.

(출처 : JPA ORM 표준 JPA 프로그래밍)
